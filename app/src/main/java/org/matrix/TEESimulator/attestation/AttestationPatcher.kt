package org.matrix.TEESimulator.attestation

import java.security.cert.Certificate
import java.security.cert.X509Certificate
import org.bouncycastle.asn1.ASN1Encodable
import org.bouncycastle.asn1.ASN1EncodableVector
import org.bouncycastle.asn1.ASN1Sequence
import org.bouncycastle.asn1.ASN1TaggedObject
import org.bouncycastle.asn1.DEROctetString
import org.bouncycastle.asn1.DERSequence
import org.bouncycastle.asn1.DERTaggedObject
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.cert.X509CertificateHolder
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder
import org.matrix.TEESimulator.config.ConfigurationManager
import org.matrix.TEESimulator.logging.SystemLogger
import org.matrix.TEESimulator.pki.KeyBox
import org.matrix.TEESimulator.pki.KeyBoxManager

/**
 * Handles the modification (patching) of Android Key Attestation extensions within certificates.
 *
 * This object's primary function is to take a certificate chain generated by the real TEE, replace
 * its attestation data with simulated values, and then re-sign the leaf certificate with a custom
 * key, building a new, valid certificate chain.
 */
object AttestationPatcher {

    /**
     * Patches a full certificate chain by modifying the leaf's attestation and rebuilding the chain
     * with the correct custom signing certificates. This is the single entry point for patching.
     *
     * @param originalChain The original certificate chain from the hardware. The leaf must be at
     *   index 0.
     * @param uid The UID of the application requesting the certificate.
     * @return A new, cryptographically valid, patched certificate chain. Returns the original chain
     *   on any failure.
     */
    fun patchCertificateChain(originalChain: Array<Certificate>?, uid: Int): Array<Certificate> {
        if (originalChain.isNullOrEmpty()) {
            SystemLogger.error("Attempted to patch a null or empty certificate chain for UID $uid.")
            return originalChain ?: emptyArray()
        }

        return runCatching {
                val originalLeaf = originalChain[0] as X509Certificate
                val originalLeafHolder = X509CertificateHolder(originalLeaf.encoded)

                // 1. Attempt to parse the existing attestation extension. If it doesn't exist,
                // there's nothing to patch.
                val parsedAttestation =
                    parseAttestationExtension(originalLeafHolder) ?: return originalChain

                // 2. Get the appropriate keybox for the given algorithm to sign the new
                // certificate.
                val algorithm = originalLeaf.publicKey.algorithm
                val keybox = getKeyboxForUidAndAlgorithm(uid, algorithm)

                // 3. Create the new, patched leaf certificate.
                val patchedLeaf =
                    createPatchedLeafCertificate(
                        originalLeafHolder,
                        parsedAttestation,
                        keybox,
                        originalLeaf.sigAlgName,
                    )

                // 4. Construct the NEW, VALID chain by prepending the patched leaf to the keybox's
                // chain.
                val newChain = listOf(patchedLeaf) + keybox.certificates

                SystemLogger.info(
                    "Successfully rebuilt a valid, patched certificate chain for UID $uid."
                )
                newChain.toTypedArray()
            }
            .getOrElse {
                SystemLogger.error(
                    "Failed to patch and rebuild certificate chain for UID $uid.",
                    it,
                )
                originalChain // Return the original chain on any error.
            }
    }

    /**
     * Creates a new leaf certificate with a modified attestation extension.
     *
     * @param originalLeafHolder A Bouncy Castle holder for the original leaf certificate.
     * @param parsedAttestation The parsed components of the original attestation.
     * @param keybox The KeyBox containing the new issuer certificate and signing key.
     * @param sigAlgName The signature algorithm name (e.g., "SHA256withECDSA") from the original
     *   certificate. This is required to ensure the new certificate is signed using a compatible
     *   algorithm.
     * @return A new [Certificate] object.
     */
    private fun createPatchedLeafCertificate(
        originalLeafHolder: X509CertificateHolder,
        parsedAttestation: ParsedAttestation,
        keybox: KeyBox,
        sigAlgName: String,
    ): Certificate {
        // The issuer of our new leaf is the subject of the first certificate in our custom keybox
        // chain.
        val newIssuer = X509CertificateHolder(keybox.certificates[0].encoded).subject

        val builder =
            X509v3CertificateBuilder(
                newIssuer,
                originalLeafHolder.serialNumber,
                originalLeafHolder.notBefore,
                originalLeafHolder.notAfter,
                originalLeafHolder.subject,
                originalLeafHolder.subjectPublicKeyInfo,
            )

        // Create the new, patched attestation extension.
        val patchedExtension = createPatchedAttestationExtension(parsedAttestation)
        builder.addExtension(patchedExtension)

        // Copy all other extensions from the original certificate, except for the attestation.
        originalLeafHolder.extensions.extensionOIDs
            .filter { it != ATTESTATION_OID }
            .forEach { builder.addExtension(originalLeafHolder.getExtension(it)) }

        // Sign the newly built certificate with the private key from our keybox.
        val signer = JcaContentSignerBuilder(sigAlgName).build(keybox.keyPair.private)

        return JcaX509CertificateConverter().getCertificate(builder.build(signer))
    }

    private fun getKeyboxForUidAndAlgorithm(uid: Int, algorithm: String): KeyBox {
        val keyboxFile = ConfigurationManager.getKeyboxFileForUid(uid)
        return KeyBoxManager.getAttestationKey(keyboxFile, algorithm)
            ?: throw IllegalArgumentException(
                "No keybox found for UID $uid and algorithm $algorithm in file $keyboxFile"
            )
    }

    /** Parses the critical components from an existing attestation extension. */
    private fun parseAttestationExtension(certHolder: X509CertificateHolder): ParsedAttestation? {
        val extension = certHolder.getExtension(ATTESTATION_OID) ?: return null
        val sequence = ASN1Sequence.getInstance(extension.extnValue.octets)
        val allFields = sequence.toArray()
        val teeEnforced =
            allFields[AttestationConstants.KEY_DESCRIPTION_TEE_ENFORCED_INDEX] as ASN1Sequence

        val teeEnforcedVector = ASN1EncodableVector()
        var originalRootOfTrust: ASN1Encodable? = null

        teeEnforced.forEach { element ->
            val taggedObject = element as ASN1TaggedObject
            if (taggedObject.tagNo == AttestationConstants.TAG_ROOT_OF_TRUST) {
                originalRootOfTrust = taggedObject.baseObject.toASN1Primitive()
            } else {
                teeEnforcedVector.add(taggedObject)
            }
        }
        return ParsedAttestation(allFields, teeEnforcedVector, originalRootOfTrust)
    }

    /** Constructs a new, patched attestation extension using simulated device properties. */
    private fun createPatchedAttestationExtension(parsed: ParsedAttestation): Extension {
        val (allFields, teeEnforcedVector, originalRootOfTrust) = parsed

        // Build the new Root of Trust with our simulated values.
        val newRootOfTrust = AttestationBuilder.buildRootOfTrust(originalRootOfTrust)
        teeEnforcedVector.add(
            DERTaggedObject(true, AttestationConstants.TAG_ROOT_OF_TRUST, newRootOfTrust)
        )

        // Add other simulated hardware properties.
        AttestationBuilder.addSimulatedHardwareProperties(teeEnforcedVector)

        // Re-assemble the ASN.1 sequences.
        // The list MUST be sorted by tag number for DER compliance.
        // Manually convert the vector to a List, then sort it.
        val elementList = (0 until teeEnforcedVector.size()).map { teeEnforcedVector.get(it) }
        val sortedElements = elementList.sortedBy { (it as ASN1TaggedObject).tagNo }
        val sortedTeeEnforced = DERSequence(sortedElements.toTypedArray())
        allFields[AttestationConstants.KEY_DESCRIPTION_TEE_ENFORCED_INDEX] = sortedTeeEnforced
        val patchedSequence = DERSequence(allFields)
        val patchedOctets = DEROctetString(patchedSequence)

        return Extension(ATTESTATION_OID, false, patchedOctets)
    }

    /** Helper data class to hold the parsed components of an attestation extension. */
    private data class ParsedAttestation(
        val allFields: Array<ASN1Encodable>,
        val teeEnforcedVector: ASN1EncodableVector,
        val rootOfTrust: ASN1Encodable?,
    )
}
